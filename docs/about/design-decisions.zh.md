# 设计决策

本文档解释 clinvk 中的关键设计决策及其背后的理由。

## 为什么封装 CLI 工具？

### 决策

clinvk 封装现有的 AI CLI 工具（Claude Code、Codex CLI、Gemini CLI），而不是直接调用 API。

### 理由

1. **利用现有工具**：每个 AI 提供商都在其 CLI 工具上投入了大量资源：
   - 代理能力（文件编辑、命令执行）
   - 上下文管理
   - 安全功能和防护措施

2. **自动更新**：当提供商更新其 CLI 增加新功能或模型时，clinvk 无需代码更改即可受益。

3. **无需 API 密钥管理**：底层 CLI 处理认证，clinvk 不需要管理 API 密钥。

4. **完整功能访问**：所有 CLI 功能保持可访问，包括工具使用、文件操作和交互模式。

### 权衡

- 需要安装 CLI 工具
- 依赖 CLI 输出格式稳定性
- 对底层 API 参数控制较少

## 为什么使用统一接口？

### 决策

无论使用哪个后端，都提供相同的命令和选项。

### 理由

1. **降低学习曲线**：学一次，到处用
2. **轻松切换**：用一个参数更换后端
3. **工作流可移植**：相同脚本适用于不同后端
4. **公平对比**：使用相同提示对比后端

### 实现

```go
type Backend interface {
    Name() string
    Execute(ctx context.Context, opts ExecuteOptions) (*Result, error)
    Available() bool
}
```

所有后端实现此接口，实现多态使用。

## 为什么链式执行使用临时模式？

### 决策

链式执行始终在临时模式下运行——步骤之间不持久化会话。

### 理由

1. **可预测性**：给定相同输入，每次链式运行产生相同结果
2. **隔离性**：步骤不会意外继承之前运行的上下文
3. **简单性**：无需跟踪或清理会话
4. **可组合性**：链可以嵌套或组合而无副作用

### 权衡

需要在链中持久化会话的用户必须在 clinvk 外部显式管理。

## 为什么提供 OpenAI/Anthropic 兼容 API？

### 决策

HTTP 服务器提供与 OpenAI 和 Anthropic SDK 兼容的端点。

### 理由

1. **生态系统兼容**：使用现有 SDK、工具和框架
2. **易于集成**：现有代码的直接替换
3. **LangChain/LangGraph**：开箱即用支持流行 AI 框架
4. **降低迁移成本**：无需重写即可从直接 API 切换到 CLI 支持

### 实现

```
POST /openai/v1/chat/completions
POST /anthropic/v1/messages
```

这些端点将 SDK 请求转换为 CLI 执行。

## 为什么使用 YAML 配置？

### 决策

使用 YAML 作为配置文件格式，而非 JSON、TOML 或纯环境变量。

### 理由

1. **人类可读**：易于手动阅读和编辑
2. **支持注释**：可以内联记录配置
3. **熟悉**：在 DevOps 和云原生工具中常见
4. **层次化**：自然适合嵌套配置

### 示例

```yaml
# 所有命令的默认后端
default_backend: claude

backends:
  claude:
    model: claude-opus-4-5-20251101
    # 将文档包含在上下文中
    extra_flags:
      - "--add-dir"
      - "./docs"
```

## 为什么将并行和链式作为原语？

### 决策

提供 `parallel` 和 `chain` 作为一等命令，而非脚本解决方案。

### 理由

1. **常见模式**：这是两种最常见的多后端工作流
2. **优化实现**：内置并发控制、错误处理
3. **一致输出**：无论任务数量，结构化结果
4. **可组合性**：可与 shell 脚本组合或通过 API 使用

### 并行 vs 链式

| 方面 | 并行 | 链式 |
|------|------|------|
| 执行 | 并发 | 顺序 |
| 数据流 | 独立 | 可用前一步输出 |
| 用例 | 多视角 | 多阶段处理 |
| 速度 | 快（最大任务时间） | 慢（任务时间之和） |

## 为什么没有内置认证？

### 决策

HTTP 服务器没有内置认证机制。

### 理由

1. **本地优先**：主要用例是本地开发
2. **需求多样**：认证需求差异很大（API 密钥、OAuth、mTLS）
3. **更好的方案存在**：反向代理处理认证更好
4. **简单性**：让代码库专注于核心功能

### 建议

生产使用时，将 clinvk 放在反向代理（nginx、Caddy、Traefik）后面处理：

- TLS 终结
- 认证
- 速率限制
- 请求日志

## 为什么使用 Go？

### 决策

用 Go 实现 clinvk。

### 理由

1. **单一二进制**：无运行时依赖，易于分发
2. **跨平台**：从一个代码库编译 Linux、macOS、Windows
3. **性能**：快速启动，低内存使用
4. **并发**：goroutine 非常适合并行执行
5. **CLI 生态**：优秀的库（Cobra、Viper）

## 未来考虑

### 潜在新增功能

- **流式支持**：后端实时输出
- **插件系统**：无需 fork 的自定义后端
- **工作流 DSL**：声明式格式的复杂多步骤工作流
- **指标/追踪**：生产使用的可观测性

### 指导原则

1. **保持简单**：避免功能蔓延
2. **封装优先**：不重复 CLI 已有功能
3. **可组合性**：从简单构建复杂
4. **稳定性**：保持向后兼容
